#!/usr/bin/env python
import numpy as np
import pandas as pd
import rospy
from arduino_magnetic_sensor.msg import xServerMsg
import matplotlib.pyplot as plt

class ContactDetector:

    def __init__(self):
        # initially empty buffer
        self.readings_buffer = []
        self.buffer_size = 10

        # to detect contact changes
        self.last_avg_reading = None
        self.change_threshold = 10
        self.touching = False

        #timing
        self.t = 0
        self.t_change = 0 # time of last change
        self.check_period = 5 # do not check every sample

    def add_reading(self, x, y, z):
        reading = np.array([x, y, z])
        self.readings_buffer.append(reading)

        # maintain buffer size, remove oldest
        if len(self.readings_buffer) > self.buffer_size:
            self.readings_buffer.pop(0)

        self.t += 1

        if self.t % self.check_period == 0:
            self.update_contact()

    def update_contact(self):
        # buffer not full
        if len(self.readings_buffer) < self.buffer_size:
            return

        change = self.contact_change()

        # ignore short jumps
        if self.t < self.t_change + self.check_period * 20:
            return

        if not self.touching and change > self.change_threshold:
            print('added touch (%f)' % change)
            self.touching = True
            self.t_change = self.t

        if self.touching and -change > self.change_threshold:
            print('removed touch (%f)' % change)
            self.touching = False
            self.t_change = self.t

    def contact_change(self):
        """ check if the contact status changed in the last buffer """
        change = 0

        average_reading = np.mean([np.linalg.norm(x) for x in self.readings_buffer])

        if self.last_avg_reading is not None:
            change = average_reading - self.last_avg_reading

        # update last reading
        self.last_avg_reading = average_reading

        print(change)
        return change

    def get_contact(self):
        return self.touching


class SensitivityBagToCsv:

    def __init__(self):
        rospy.init_node('sensitivity_experiment')

        rospy.Subscriber("/xServTopic", xServerMsg, self.tactile_reading_callback)

        self.filename = rospy.get_param('~filename', 'output')

        # timing
        self.t = 0
        self.t_grounding = 20

        self.contact_detector = ContactDetector()

        # create a dataframe to write csv
        self.df_readings = pd.DataFrame(columns=['time', 'norm', 'x', 'y', 'z','touch'])
        self.df_ground = pd.DataFrame(columns=['time', 'norm', 'x', 'y', 'z','touch'])

    def tactile_reading_callback(self, msg):
        row_data = {'time':[self.t]}
        self.t += 1

        # create a np array for each point
        point = msg.points[0].point
        norm_val = np.linalg.norm([point.x, point.y, point.z])
        row_data['norm'] = [norm_val]
        row_data['x'] = [point.x]
        row_data['y'] = [point.y]
        row_data['z'] = [point.z]
        row_data['touch'] = [False] # using [] because df.from_dict wants it

        ground = self.ground_readings(row_data)
        if ground is False:
            return

        self.contact_detector.add_reading(point.x, point.y, point.z)
        row_data['touch'] = self.contact_detector.get_contact()

        # print '.',
        grounded_reading = pd.DataFrame.from_dict(row_data) - self.df_ground
        self.df_readings = self.df_readings.append(grounded_reading, ignore_index=True)

    def ground_readings(self, row_data):
        # collect initial readings
        if self.t < self.t_grounding:
            self.df_ground = self.df_ground.append(pd.DataFrame.from_dict(row_data), ignore_index=True)
            return False
        # set the ground
        if self.t == self.t_grounding:
            self.df_ground = self.df_ground.mean()
            self.df_ground['time'] = 0
            print 'ground:'
            print self.df_ground

        return self.df_ground

    def write_csv(self):
        print(self.df_readings.head())
        self.df_readings.to_csv(self.filename + '.csv', index=False)

        print(self.df_ground)

        print('saving plot' + self.filename + '.png')
        plt.plot(self.df_readings['time'], self.df_readings['norm'], label='norm (grounded)')
        plt.plot(self.df_readings['time'], self.df_readings['touch']*10, label='touch (scaled)')
        plt.legend(loc='best')
        plt.savefig(self.filename + '.png')
        plt.show()


if __name__ == '__main__':
    node = SensitivityBagToCsv()

    while not rospy.is_shutdown():
        pass

    print('Terminating & writing csv')
    node.write_csv()
