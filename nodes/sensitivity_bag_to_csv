#!/usr/bin/env python
import numpy as np
import pandas as pd
import rospy
from arduino_magnetic_sensor.msg import xServerMsg

class ContactDetector:

    def __init__(self):
        # initially empty buffer
        self.readings_buffer = []
        self.buffer_size = 10

        # to detect contact changes
        self.last_avg_reading = None
        self.change_threshold = 15
        self.touching = False

        self.t = 0

    def add_reading(self, x, y, z):
        reading = np.array([x, y, z])
        self.readings_buffer.append(reading)

        # maintain buffer size, remove oldest
        if len(self.readings_buffer) > self.buffer_size:
            self.readings_buffer.pop(0)

        self.t += 1

        if self.t % 5 == 0:
            self.update_contact()

    def update_contact(self):
        if len(self.readings_buffer) < self.buffer_size:
            return

        change = self.contact_change()
        if not self.touching and change > self.change_threshold:
            print('added touch (%f)' % change)
            self.touching = True

        if self.touching and -change > self.change_threshold:
            print('removed touch (%f)' % change)
            self.touching = False

    def contact_change(self):
        """ check if the contact status changed in the last buffer """
        change = 0

        average_reading = np.mean([np.linalg.norm(x) for x in self.readings_buffer])

        if self.last_avg_reading is not None:
            change = average_reading - self.last_avg_reading

        # update last reading
        self.last_avg_reading = average_reading

        print(change)
        return change

    def get_contact(self):
        return self.touching


class SensitivityBagToCsv:

    def __init__(self):
        rospy.init_node('sensitivity_experiment')

        rospy.Subscriber("/xServTopic", xServerMsg, self.tactile_reading_callback)

        # timing
        self.t = 0

        self.contact_detector = ContactDetector()

        # create a dataframe to write csv
        self.df_readings = pd.DataFrame(columns=['time', 'norm', 'x', 'y', 'z'])

    def tactile_reading_callback(self, msg):
        row_data = {'time':self.t}
        self.t += 1

        # create a np array for each point
        point = msg.points[0].point
        norm_val = np.linalg.norm([point.x, point.y, point.z])
        row_data['norm'] = norm_val
        row_data['x'] = point.x
        row_data['y'] = point.y
        row_data['z'] = point.z

        self.contact_detector.add_reading(point.x, point.y, point.z)
        row_data['touch'] = self.contact_detector.get_contact()

        # print(row_data)
        # print '.',
        self.df_readings = self.df_readings.append(row_data, ignore_index=True)

    def write_csv(self):
        print(self.df_readings.head())
        self.df_readings.to_csv('output.csv', index=False)


if __name__ == '__main__':
    node = SensitivityBagToCsv()

    while not rospy.is_shutdown():
        pass

    print('Terminating & writing csv')
    node.write_csv()
